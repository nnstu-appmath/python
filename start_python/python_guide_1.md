# Начало работы с Python
![Настоящий питон](13309.jpg)
## Установка Python
В самом начале необходимо установить сам Python. Сделать это можно следующими путями:

### Для Windows:
   1. Скачать с официального сайта и установить (https://www.python.org/downloads/);
   2. Скачать среду разработки, которая сама предложит установить язык.

### Для Linux/Unix:

  1. Скачать с официального сайта архив `.tgz` (https://www.python.org/downloads/source/)
  2. Распаковать и далее установить (Подробно описано, например, тут: https://lumpics.ru/how-to-install-tar-gz-in-ubuntu/)

**Все!** Вы уже можете писать код на Python.

## Среды разработки и редакторы кода Python
Конечно, код можно писать и в консоли Python (о чем будет рассказано позже), но удобнее использовать какие-либо программы для упрощения работы над разработкой кода. Как вы можете догадаться, **IDE (интегрированная среда разработки) и редакторов кода** существует множество и каждый разработчик выбирает то, что удобно именно ему.

Чем же отличается IDE от редакторов кода? IDE имеет больший функционал, в отличие от редакторов кода. Однако, для большинства задач можно выбирать и редактор кода. Впрочем, как и сказано ранее, каждый выбирает сам.

#### Лучшие редакторы кода для Python:
1. **Python IDLE** - редактор кода, установливаемый вместе с Python (лежит в той же папке, где и Python). Прекрасный редактор для начала программирования и понимания основ языка.

  *Плюсы:*
   - устанавливается вместе с Python
   - легкий в использовании, для начинающих

  *Минусы:*
   - нет большого функционала
   - не подходит для больших проектов


2. **Sublime Text** (https://www.sublimetext.com/3) - редактор, написанный инженером из Google с мечтой о лучшем текстовом редакторе. Является весьма популярным редактором кода, доступным на всех платформах.

  *Плюсы:*
   - простой и легкий в использовании
   - поддержка сообщества
   - пробным периодом можно пользоваться вечно

   *Минусы:*
   - все-таки редактор платный...
   - для установки дополнительных пакетов придется потанцевать с бубном


3. **Visual Studio Code** (https://code.visualstudio.com/download) - бесплатный редактор кода от Microsoft, доступен на всех платформах.

  *Плюсы:*
   - интеграция с Git
   - потребляет не так много памяти
   - имеет встроенный терминал
   - простая установка дополнительных пакетов
   - большой функционал: отладка, подсветка синтаксиса, интеллектуальное завершение кода, предопределённые фрагменты кода, рефакторинг

  *Минусы:*
  - работает не как нативное приложение, а как JavaScript-процесс.


4. **Vim** — это текстовый редактор, предустановленный в системах MacOS и UNIX.

  *Плюсы:*
   - легкий, эффективный и производительный
   - уже установлен на системах Unix
   - можно добавить плагины для расширения функционала: отладка, подсветка синтаксиса, интеллектуальное завершение кода, предопределённые фрагменты кода, рефакторинг

  *Минусы:*
   - сложен в изучении
   - не для Windows

#### Лучшие IDE для Python:
1. **Visual Studio** (https://visualstudio.microsoft.com/ru/downloads/) - полнофункциональная IDE от Microsoft, позволяет разрабатывать приложения для разных платформ и предоставляет свой собственный набор расширений.

  *Плюсы:*
   - легкий в использовании
   - большой функционал
   - интеграция с Git
   - простая установка дополнительных пакетов

  *Минусы:*
   - слишком жирно для разработки только лишь на Python
   - нет версии для Linux


2. **PyCharm** (https://www.jetbrains.com/pycharm/download/#section=windows) - IDE, разработанная специально для Python, имеет широкий набор возможностей, доступная на всех платформах.

  *Плюсы:*
   - имеет очень большой функционал
   - поддержка различных виртуальных сред Python
   - поддержка системы управления версиями
   - не требуется установка дополнительных расширений
   - написание кода → запуск и отладка из среды

   *Минусы:*
   - тормозит при малом количестве оперативной памяти (< 8Гб)


3. **Spyder** - мощная научная интегрированная среда программирования, написанная на Python, для Python. Она разработана учеными, инженерами и аналитиками данных для них самих.

  *Плюсы:*
   - бесплатный редактор, поставляется с Anaconda (виртуальная среда)
   - Open Source
   - наличие проводника переменных
   - имеет функционал, типичный для IDE
   - подходит для Data Scientist, использующих Anaconda

  *Минусы:*
   - недостаточная функциональность для повседневной работы с точки зрения более опытных разработчиков


4. **Thonny** -  IDE для новичков, написанна и поддерживается Институтом информатики Тартуского университета в Эстонии, доступна на всех основных платформах.

  *Плюсы:*
   - для начинающих
   - предустановлена на системы Linux
   - имеет функционал, типичный для IDE

  *Минусы:*
   - недостаточность функционала
   - склонен к проблемам из-за новизны среды

## Основные отличия Python от других языков программирования
В данном разделе не будет рассматриваться подробный синтаксис языка. Будут приведены лишь основные моменты.

1. **Интерпретируемый язык** - код читается и выполняется интерпретатором построчно. Комипилируемые же языки, сначала преобразуют код в машинный язык, а потом его можно запутить.
2. **Простой синтаксис** - новая строчка обозначается переводом строки. Никаких `;` и `{ }`. Для функций или циклов используются отступы (4 пробела или 1 табуляция). Да и в целом синтаксис языка прост в изучении.
3. **Динамическая типизация** - типы данных проверяются при работе программы, а не на этапе компиляции, как у компилируемых языков. В коде на Python можно и не указывать тип данных, язык сам поймет, что вы написали.
4. **Портативность** - код можно запустить на любой платформе. Код на компилируемом языке придется компилировать на каждой платформе.
5. **Автоматическая сборка мусора** - разработчику не нужно задумываться о том, как управлять памятью. Язык все делает автоматически.
6. **Низкая скорость и производительность** - этот минус присущ любым интерпретируемым языкам программирования. Код будет выполняться в разы медленнее, чем на комплириуемых языках.
7. **Обилие библиотек** - для (практически) любых целей уже (скорее всего) сделана библиотека на Python. Это упрощает жизнь разработчикам - не нужно изобретать велосипед.

**Кстати**, программируя на Python полезно прочитать конвенцию, т.е. общепринятое соглашение о том, как надо называть функции, классы и т.д. (https://peps.python.org/pep-0008/)


## Работа с Python в консоли/терминале
Для простых вычислений и небольшого кода совсем не требуется наличие редактора или среды. В Python-консоли можно выполнять простой код. Однако для проектов, отладки и других функций следует использовать редактор или среду. В общем-то, если надо посчитать 2+2, то можно воспользоваться консолью.

### Запуск Python-консоли:
1. **На Windows:**
  - в строке поиска приложений ввести `python` и нажать на приложение
  - вызвать командную строку и в ней ввести `python`
    + в строке поиска ввести `cmd` и нажать на приложение
    + сочетание клавиш `WIN + R`, ввести `cmd`
2. **На Linux:** в терминале ввести `python3` (зависит от установленной версии)
3. **В среде разработки**: Python-консоль можно запустить и из среды разработки (если не очень хочется создавать файл и запускать его). Например, в *PyCharm* на нижней панели самая последняя кнопка - Python Console.

### Примеры работы с Python-консолью

Строка ввода в Python-консоли отображается как `>>>`. Именно после них пишется строка кода.
1. Простые вычисления
```
>>> 2+2
4
```
```
>>> 3**5
243
```
2. Более сложные вычисления
```
>>> i = 2
>>> for j in range (0, 5, 1):
...     print(i**j)
...
1
2
4
8
16
```
```
>>> def hello():
...     print("Hello World!")
...
>>> hello()
Hello World!
```
В общем-то, в Python-консоли можно написать (а также вставить уже написанный) код, который умещается в один файл `.py `. Естественно, в разработке больших проектов консоль не будет удобной.

  *Плюсы:*
  - можно выполнить небольшой код
  - подходит для небольших задач
  - нет необходимости скачивать среду или редактор

  *Минусы:*
  - не подходит для проектов
  - нет возможности отладки
  - нет возможности правки кода (построчная интерпретация кода)
  - нет возможности сохранить код

## Структура кода Python
Как можно догадаться - код, который пишется на языке Python, должен иметь расширение `.py`. Создав Python-файл, можно начать писать код.
Но какой же синтаксис? Как именно написать код? Структура кода на Python может быть разной.

0. **Библиотеки** - вне зависимости, как вы хотите написать код, необходимые библиотеки подключаются в начале кода с помощью слова `import`. Существует три варианта подключения библиотек:

    1. *Импортировать всю библиотеку* - обращаться к ее методам придется по ее полному имени
    ```
     import numpy
     print(numpy.sqrt(5))
    ```
    ```
     2.23606797749979
    ```
    2. *Импортировать всю библиотеку под псведонимом* - обращаться к ее методам по псевдониму
    ```
     import numpy as np
     print(np.sqrt(5))
    ```
    ```
     2.23606797749979
    ```
    3. *Импортировать необходимые методы из библиотеки* - если вам не нужна вся библиотека, а лишь один или несколько методов
    ```
     from numpy import sqrt
     print(sqrt(5))
    ```
    ```
     2.23606797749979
    ```
1. **Сплошной код.** Вам не нужно обозначать функцию `main()`, как в других языках. Создайте файл, пишите действия, которые необходимо сделать, разделяйте их переводом строки и запускайте код. Пример:
```
 a = 1
 b = 2
 print(a - b)
 c = 3
 d = 4
 print(c - d)
```
```
 -1
 -1
```
2. **Разделение на функции.** Иногда для решения задачи, нужно выполнять одни и те же действия несколько раз. Для уменьшения кода пишут функции, которые можно вызывать n-количество раз.

  ***Функция*** обозначается служебным словом `def`. Далее через пробел следует название функции `name`. В скобках указываются передаваемые переменные `(a, b, c)`. Если передавать не надо, то скобки остаются пустыми `()`. В конце ставится двоеточие `:`. Тело функции отделяется 4 пробелами или 1 табуляцией. Если необходимо вернуть значение из функции, то в конце пишется служебное слово `return` и само передаваемое значение. Значений можно передать несколько, перечисляются они через запятую. Соответственно, при вызове функции, необходимо присваивать возвращаемые значения тому же количеству переменных. **Итого:**
  ```
  def multiply(number_1, number_2, number_3):
      multiply_1_2 = number_1 * number_2
      multiply_1_3 = number_1 * number_3
      multiply_2_3 = number_2 * number_3
      return multiply_1_2, multiply_1_3, multiply_2_3

  a, b, c = multiply(2, 3, 4)
  ```
  Есть два варианта структуры кода в данном случае:
   - написать функцию, а дальше код "как бы" главной функции `main()`
   ```
    def minus(a, b):
        print(a - b)

    minus(1, 2)
    minus(3, 4)
   ```
   ```
    -1
    -1
   ```
   - написать функцию и обозначить функцию `main()`
   ```
    def minus(a, b):
         print(a - b)

    if __name__ == "__main__":
        minus(1, 2)
        minus(3, 4)
   ```
   ```
    -1
    -1
   ```
   Есть ли разница между способами? Наверное, второй способ упрощает читаемость кода. Но можно использовать и первый.
3. **Разделение на файлы.** В больших проектах весь код невозможно адекватно уместить в одном файле. Для читаемости кода и в целом для удобства следует выносить функции или, например, классы в отдельные файлы. Подключаются они также как и библиотеки. Запускать же надо главный файл.

  Файл `minus.py`:
  ```
    def minus(a, b):
       print(a - b)
  ```
  Файл `main.py`:
  ```
    import minus as m

    m.minus(1, 2)
    m.minus(3, 4)
  ```
  ```
    -1
    -1
  ```

## Классы и ООП
Конечно, про то, что такое **ООП** и с чем его едят, следует почитать в полезных книжках или статьях в интернете (Например, [тут](https://vk.com/wall-54530371_249976) даже `.pdf` файлы книжек).

Вкратце, 4 основных принципа **ООП**:

- *Абстракция.* Моделирование требуемых атрибутов и взаимодействий сущностей в виде классов для определения абстрактного представления системы
- *Инкапсуляция.* Скрытие внутреннего состояния и функций объекта и предоставление доступа только через открытый набор функций
- *Наследование.* Возможность создания новых абстракций на основе существующих
- *Полиморфизм.* Возможность реализации наследуемых свойств или методов отличающимися способами в рамках множества абстракций

**Так зачем нужны классы?** В обычном коде - незачем. Для больших проектах - это необходимость. Необходимость структурировать все данные, которые есть, а также методы, которые работают с этими данными и представлять в абстрактном виде. На этом построен принцип *абстракции.*

Также классы могут *наследовать* методы и переменные других классов. Например, есть класс-родитель `Phone`, который имеет такие характеристики, как, например, `width`, `height`, `memory` и другие. А есть класс-наследник `iPhone`, который имеет к доступ к характеристикам класса `Phone`, а также имеет свои собственные: `iOS_version`, `have_apple_watch`. Второй класс-наследник `Samsung`, также имеет доступ к `Phone` и плюс свои переменные: `android_version`, `have_samsung_galaxy_watch`.

**Итого:** `iPhone` имеет ширину, высоту, объем памяти, версию iOS и наличие Apple Watch, а `Samsung` - ширину, высоту, объем памяти, версию Android и наличие Samsung Galaxy Watch.

Мы могли бы написать два класса вместо трех, но классы имеют общие переменные, мы можем сделать родительский класс с общими характеристиками.

*Инкапсуляция* же представляет собой ограничение доступа к переменным класса. Есть три типа доступа:
1. Приватный (private) - доступ только в самом классе
2. Защищенный (protected) - доступ в самом и дочерних классах
3. Публичный (public) - доступ откуда угодно

Однако, в Python реального сокрытия данных не существует, все действует на уровне соглашений, объявляя атрибуты "приватными" с помощью нижнего подчеркивания `_name`. Также поставив двойное подчеркивание `__name`, нельзя будет обратиться к переменной напрямую (на самом деле можно, но обходным путем, лучше написать методы получения значения `get`).

*Полиморфизм* - это способность обьекта использовать методы дочернего класса, который не существует на момент создания родителя, т.е. мы можем переопределять методы родителя с помощью методов наследника.

Итак, класс обозначается служебным словом `class`, далее название класса `Name`, а в скобках указываются классы-родители, если они есть `(Parent_1)`.

Как и в функциях, с помощью табуляции определяется тело класса - переменные и методы. Переменные делятся на **переменные экземпляров и переменные класса.** Переменные класса используются, если для любых экземпляров класса эта переменная должна быть всегда одна и та же. Например, для класса `Phone` переменная класса - `memory`. И экземпляры `Phone_1` и `Phone_2` будут иметь одинаковый объем памяти. А переменные экземпляра используются только экземплярами и объявляются в методах. То есть переменная `width` будет определяться по разному для каждого телефона, т.е. экземпляра.

Также в методах используется служебное слово `self` - общепринятое имя для ссылки на объект, в контексте которого вызывается метод. Этот параметр обязателен и отличает метод класса от обычной функции. Существует метод `__init__`, который вызывается при объявлении класса. Обычно он задает значения переменным.

О других специальных методах класса в Python можно почитать [в официальной документации Python](https://docs.python.org/3.7/reference/datamodel.html?highlight=getitem#emulating-numeric-types).

**Итого:**
```
class Phone:
    memory = 8

    def __init__(self, width, height):
        self.__width = width
        self.__height = height

    def get_width(self):
        return self.__width

    def get_height(self):
        return self.__height

    def hello(self):
        print("Hello, I'm a Phone!")


class iPhone(Phone):
    def __init__(self, width, height, vers, watch):
        Phone.__init__(self, width, height)
        self.ios_version = vers
        self.have_apple_watch = watch


class Samsung(Phone):
    def __init__(self, width, height, vers, watch):
        Phone.__init__(self, width, height)
        self.android_version = vers
        self.have_samsung_galaxy_watch = watch

    def hello(self):
        print("Hello, I'm Samsung!")


phone_1 = Phone(9, 15)
phone_2 = Phone(7, 10)
print("Memory: ", phone_1.memory, ", Width: ", phone_1.get_width(), ", Height: ", phone_1.get_height())
print("Memory: ", phone_2.memory, ", Width: ", phone_2.get_width(), ", Height: ", phone_2.get_height())
iphone_13 = iPhone(7, 14, 16.2, True)
samsung_a52 = Samsung(7, 15, 13, False)
iphone_13.hello()
samsung_a52.hello()
print("Memory: ", iphone_13.memory, ", Width: ", iphone_13.get_width(), ", Height: ", iphone_13.get_height(),
", iOS version: ", iphone_13.ios_version, ", Apple Watch: ", iphone_13.have_apple_watch)
print("Memory: ", samsung_a52.memory, ", Width: ", samsung_a52.get_width(), ", Height: ", samsung_a52.get_height(),
", Android version: ", samsung_a52.android_version, ", Apple Watch: ", samsung_a52.have_samsung_galaxy_watch)
```
**Рассмотрим подробнее классы:**
1. В классе-родителе `Phone` мы определили переменную класса - `memory` = 8. Она не приватная, мы ее можем получить обращаясь напрямую.
2. Также определены переменные экземпляра в стандартном методе для инициализации переменных `__init__` - они объявлены приватными с помощью двойного подчеркивания и мы написали для них методы `get` для получения значений переменных.
3. В родительском классе объявлена функция приветствия, характерная для любых телефонов.
4. Класс-наследник `iPhone` инициализирует не только переменные класса-родителя, но и свои, которые уже объявлены публичными. Следовательно, к таким переменным можно не писать методы для получения значений - будем обращаться напрямую.
5. Класс-наследник `Samsung` инициализирует аналогично. Однако, здесь определен метод, который переопределяет родительский метод приветствия.

**Что происходит дальше:**
1. Создаем два экземпляра родительского класса, с разными значениями высоты и ширины.
2. Выводим в консоль все переменные: к `memory` обращаемся напрямую (переменная публичная), к остальным через `get` (переменные приватные).
3. Создаем экземпляр дочерних классов `iPhone` и `Samsung`.
4. Вызываем методы приветствия для каждого экземпляра класса-наследника.
5. Выводим в консоль переменные: к приватным обращаемся через `get`, к публичным напрямую. Обратим внимание, что мы можем вызывать методы и переменные родительского класса, обращаясь через наследника. Все потому, что наследник имеет доступ к методам и переменным родителя.

**Что выведется в консоль:**
```
Memory:  8 , Width:  9 , Height:  15
Memory:  8 , Width:  7 , Height:  10
Hello, I'm a Phone!
Hello, I'm Samsung!
Memory:  8 , Width:  7 , Height:  14 , iOS version:  16.2 , Apple Watch:  True
Memory:  8 , Width:  7 , Height:  15 , iOS version:  13 , Apple Watch:  False
```
Можно заметить, что переменные вывелись, так как нужно было нам. Приветствие для `iPhone` вывелось так, как оно определено в родительском классе - в виду отсутствия этого метода в наследнике. `Samsung` же вывел переопределенный метод.

Таким образом, классы в Python имеют больший функционал и применение. Для лучшего понимания и подробного изучения следует почитать полезные ссылки, например, [официальную документацию Python по классам.](https://docs.python.org/3/tutorial/classes.html)


## Используемые источники:
1. Выбор IDE/редактора кода:
 - OTUS: Выбираем среду разработки для Python https://otus.ru/nest/post/874/
 - Хабр: Выбираем самый удобный редактор кода Python https://habr.com/ru/company/skillfactory/blog/521838/
 - Tproger: Лучшие IDE и редакторы кода для Python https://tproger.ru/translations/python-ide/

2. Отличия Python:
   - PythonRu: Топ 16 различий между Python и C++ https://pythonru.com/baza-znanij/python-ili-c
3. Классы и ООП:
   - Proglib: ООП на Python: концепции, принципы и примеры реализации https://proglib.io/p/python-oop
